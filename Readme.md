Init:
Резервируем непрерывный буфер на 2048 возможных взрывов (каждый содержит 64 частицы и счётчик живых частиц).
На самом деле создаем 2 буфера – из одного всегда будем читать данные, а в другой писать. Так же создаем доп буфер для записи ожидаемых взрывов.

Update:
При обновлении состояния частиц исходные данные всегда читаются из "render" буфера, а записываются в "update" буфер. Обновление данных может происходить в несколько потоков (см. branch multithreaded-update).
Проходим по каждому взрыву, обновляя состояние живых частиц. Мертвые частицы "удаляем из буфера", тем самым экономим время для следующего апдейта (частицы, умершие на предыдущих апдейтах, не обрабатываются).
Если во взрыве нет живых частиц, не обрабатываем его.
Ждем когда закончится рендер, а затем меняем местами буферы: update_buffer <-> render_buffer.

Render:
Получается очень легким: бежим по render_buffer и рендерим каждый активный взрыв. Одновременно из этого же буфера потоки в апдейте читают данные для обновления и записи в update_buffer.

P.S. Многопточный апдейт: идея заключается в том, чтобы разделить буферы на диапазоны и назначить каждому потоку свой. Скажем, поток1 обновляет [1; 256] взрыв, поток2 [257; 512], ... .
Идею можно посмотреть в ветке multithreaded-update. Реализация, на мой взгляд, получилась не очень оптимальной.